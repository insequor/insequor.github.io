---
layout: post
title: Where Do Blocks Go?
tags: design
---

Using LEGO in training activities is nothing new. The bricks found their use in exercises from team building activities to product design problems. Building constructions for given constraints is an interesting and entertaining activity. But I found what happens afterwards more interesting and more challenging. And perhaps, more relevant to product design problems. Where do the bricks go when you are done playing?

I am one of those parents who counted LEGOs as pluses of having a kid. I waited patiently for him growing up from large simple bricks to simple LEGO Technic sets. I was a proud father the first time we spent a couple of hours to make a single set together. But those happy moments, just like your team building activity, do not last long. Pieces arriving in neat boxes and numbered bags tend to mix up and spread all over the house. Reality kicks in when one sleepy morning you step on the bricks while trying to reach for your coffee and start realizing that the bricks need to go somewhere.

I have a couple of failed attempts to organize the bricks in my personal history. My last attempt overlapped with the time I listened to John Ousterhout’s talk titled [A Philosophy of Software Design](https://www.youtube.com/watch?v=bmSAYlu0NcY). I owe it to this talk, especially to the [topic of deep vs shallow classes](https://www.youtube.com/watch?v=bmSAYlu0NcY&t=13m10s), to make the connection between product design and organizing my son’s LEGOs. In short, it goes like this: Assume that the thing you design is a rectangle. The width of this rectangle is its interface, how the others will interact with it. The area of the rectangle represents the value you are bringing with it. The interface is associated with the cost, in other words, what the world needs to learn to use the thing you designed so they can get the value. The design problem is the optimization of cost versus the value. You need to maximize the value - bigger rectangle, and minimize the cost - smaller width. So the deeper your rectangle is the better.

To apply the shallow versus deep principle to the LEGO organization problem we need to answer these questions: What is the value? And what is the cost?

The value of the organization I thought was to find the right bricks when you need them. My suggestion to my son was something like “let’s put these bricks into the boxes so that we can find them easily when we play with them”. It is the same method I used when we made the LEGO sets: Empty all bags on the table, separate the lego bricks by colour so it is easier to find them when you follow the instructions. I considered it a good requirement since it tells what to do and why to do it. Perhaps “using a box” is an implementation detail and I should have said, “let’s organize the bricks so that…” instead. But it seems like telling what and why is not sufficient for a good requirement. We also need to question why we want that outcome. Imagine we resolved this requirement and got what we want, what do we expect to happen? What happens if I find the bricks easily? It takes less time to make a new set, I can reach my goal - finished construction - sooner. So it is good. But what happens if my son finds the bricks easily? He finishes the construction sooner, I get less quiet time. Not so good. But if there is no organization at all I will be called to help finding each piece, again ruining my quiet time. Then the value of organizing the bricks, when it comes to my son using them, is to increase my quiet time.

Here is another trick to question this requirement: For a moment let’s imagine I have a magic wand and I can get what I need without any effort, resolve the why without the what. I can find the bricks easily without the need to neatly organize them in boxes. Will I be happy? No. The bricks will still be all around the place even if we can easily find them. So the value of organizing the brick is not only for easily locating them, but also bringing them together so they are not all around the place and you don’t step on them whenever you move.
The problem is these two different value propositions might require conflicting interfaces. All you need to bring bricks together is a large box with one large opening that all types of bricks can fit in. Easily finding bricks in that box might mean that different types of bricks need to go to different compartments in the box and you have access to each compartment. I’ll assume that we are dealing with a simple box so the same interface needs to be used both to put the bricks in and to take them out. So we need to find the right amount of compartments which makes it easy enough to put the right bricks to the right compartments while it is not too difficult to find the bricks of exact type within a single compartment.

How do you categorize the bricks then? They come in different shapes, sizes and colours. According to one [Quora answer](https://www.quora.com/How-many-types-of-LEGO-bricks-parts-are-there?share=1) , there might be anything between 9000 to 60000 different brick types depending on your criteria to define a brick type. This number goes down considerably if we assume that an average household will not have all types of bricks. But which types of bricks can be found in an average household? Is my house an average household? If I decide to share my super powerful brick organizer box with more households, will it still work? Are the people in those average households average as well? My ignorance in color difference might be shared by a colour-blind person but not a colour obsessed one for example. What are other differences in people which might affect the definition of a “different brick”?
These questions, and many more, would be familiar to those who are concerned with the product design. Software design world (I refer to the code itself here) has some differences. The value of a function or a class is often about the value for the developer who is writing the code. Same goes to the cost the developer is willing to pay to use that function or class. And obviously, the developer knows very well the user. The closest we come to the above concerns is when we repeat the well-known guidance “imagine the developer who will need to maintain this code in a year”. Even then, the developer we imagine is someone like ourselves. 
And yet, John Ousterhout talks about the code when he refers to the value and cost, not the product. Alexandru Bolboaca, in his talk [Usable Software Design](https://youtu.be/enkqMu8gZSY), raises a similar concern when he asks “who is the user of the software” and invites us to see the software as a product and the developers, not just ourselves, as the users of it.

In a way, as software developers, we develop two different products simultaneously for two different user groups. I find the lack of connection between the application and the code disturbing. I know that the code I write makes the application possible, and yet, there is no physical connection between the two. You can as well imagine that the code is the order you give to the waiter in a restaurant, the compiler in our case, and the application is the thing that comes out of the kitchen. The quality of the food does not depend on the quality of the order. Yet projects succeed or fail based on how well the code is written. Thinking about the code as a product can give you a nice framework to better understand the value and the cost when discussing things such as readability, maintainability or extensibility of your code. Understanding the user of the code might be as important as understanding the user of the application. By providing the value to the users of the code, you are enabling them to provide value to the users of the application. 

If you ever found yourself debating for hours about a variable name or the function signature without an apparent reason, you might see something similar in my perfect LEGO brick organizer box quest. Perhaps you too had to compromise and be happy with “good enough” at the moment. My quest brought me some additional vocabulary to help me in my next challenge. I have the comfort of knowing that, when I struggle for no apparent reason, I will be better armed to explain what I am trying to achieve. And when I fail, I’ll have a better understanding of where I failed.
